# ==============================================================================
# Bearish Crossover (Death Cross) Simple Moving Average (SMA) Strategy Backtest using Polygon.io
# ==============================================================================

# This Jupyter notebook implements a basic backtesting framework for the 
# Bearish SMA Crossover (Death Cross) trading strategy using intraday 1-minute 
# bar data from Polygon.io.

# Strategy Description:
# ------------------------
# The Bearish SMA Crossover strategy enters a short position when a short-term
# moving average (e.g., 9-period SMA) crosses **below** a longer-term moving 
# average (e.g., 20-period SMA).
# It exits (covers) the short trade when the short-term SMA crosses back **above** 
# the long-term SMA.

# Purpose:
# ----------
# - To visualize short-side crossover trade signals.
# - To calculate simple performance metrics (PnL, win rate) from short trades.
# - To provide a basic framework for testing bearish SMA-based strategies.

# How to Use:
# -------------
# 1. Set your desired symbol and date range in the Parameters section below.
# 2. Insert your Polygon API key where indicated.
# 3. Run all cells to fetch data, calculate short signals, evaluate trades, and plot results.
# 4. Adjust short_window and long_window to explore different signal behaviors.

# Notes & Limitations:
# ---------------------
#
# - **No Risk Management**:
#     This strategy does not use stop-loss, take-profit, or slippage.
#     It assumes ideal fills on SMA crossovers.
#
# - **Short-Only Trades**:
#     The strategy enters only short trades on bearish crossovers.
#
# - **Single Entry/Exit Cycle**:
#     You must exit (cover) a short before re-entering; no overlapping trades.
#
# - **No Capital Allocation**:
#     Each trade is treated as a 1-unit short, without compounding or sizing logic.


# ==============================================================================
# Bearish Crossover (Death Cross) SMA Crossover Strategy Backtest using Polygon.io
# ==============================================================================

# === 1. Parameters ===
symbol = "AAPL"
start_date = "2024-07-01"
end_date = "2024-07-01"
short_window = 9
long_window = 20
API_KEY = "INSERT_API_KEY"

# === 2. Imports ===
import requests
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

# === 3. Fetch Data from Polygon ===
def fetch_intraday(symbol, start, end, timespan='minute', limit=50000):
    url = f"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/1/{timespan}/{start}/{end}"
    params = {
        "adjusted": "true",
        "sort": "asc",
        "limit": limit,
        "apiKey": API_KEY
    }
    r = requests.get(url, params=params)
    data = r.json().get("results", [])
    df = pd.DataFrame(data)
    if df.empty:
        print("No data returned.")
        return df
    df['t'] = pd.to_datetime(df['t'], unit='ms')
    df.set_index('t', inplace=True)
    df.rename(columns={'c': 'close'}, inplace=True)
    return df[['close']]

df = fetch_intraday(symbol, start_date, end_date)

# === 4. Strategy Logic (Bearish Crossover) ===
def run_bearish_crossover(df, short_window, long_window):
    df = df.copy()
    df['sma_short'] = df['close'].rolling(short_window).mean()
    df['sma_long'] = df['close'].rolling(long_window).mean()
    df['position'] = (df['sma_short'] < df['sma_long']).astype(int)
    df['signal'] = df['position'].diff()

    trades = []
    entry_price = None
    entry_time = None
    for i in range(1, len(df)):
        row = df.iloc[i]
        if row['signal'] == 1:  # Cover (exit short)
            if entry_price is not None:
                exit_price = row['close']
                exit_time = row.name
                pnl = entry_price - exit_price  # Short profit
                trades.append({
                    'entry_time': entry_time,
                    'exit_time': exit_time,
                    'entry_price': round(entry_price, 2),
                    'exit_price': round(exit_price, 2),
                    'pnl': round(pnl, 2)
                })
                entry_price = None
        elif row['signal'] == -1:  # Enter short
            entry_price = row['close']
            entry_time = row.name

    return df, trades

# === 5. Run Strategy ===
if not df.empty:
    df_with_signals, trades = run_bearish_crossover(df, short_window, long_window)

    # Evaluation
    total_pnl = sum(t['pnl'] for t in trades)
    win_rate = sum(1 for t in trades if t['pnl'] > 0) / len(trades) if trades else 0

    print(f"üìâ Total Trades: {len(trades)}")
    print(f"üí∞ Total P&L: {round(total_pnl, 2)}")
    print(f"‚úÖ Win Rate: {round(win_rate * 100, 2)}%")

    print("\nüìã Trade Details:")
    for t in trades:
        print(f"‚Üí {t['entry_time']} Short @ {t['entry_price']} | {t['exit_time']} Cover @ {t['exit_price']} | PnL: {t['pnl']}")

    # === 6. Plotting ===
    plt.figure(figsize=(15, 6))
    plt.plot(df_with_signals.index, df_with_signals['close'], label='Close Price', color='black')
    plt.plot(df_with_signals.index, df_with_signals['sma_short'], label=f"SMA {short_window}", alpha=0.7)
    plt.plot(df_with_signals.index, df_with_signals['sma_long'], label=f"SMA {long_window}", alpha=0.7)

    for t in trades:
        plt.axvline(t['entry_time'], color='red', linestyle='--', alpha=0.5)
        plt.axvline(t['exit_time'], color='green', linestyle='--', alpha=0.5)

    plt.title(f"{symbol} Bearish SMA Crossover Strategy ({start_date} to {end_date})")
    plt.xlabel("Time")
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()
else:
    print("‚ùå No data to run strategy.")
